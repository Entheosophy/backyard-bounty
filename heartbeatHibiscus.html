<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hibiscus â€“ Upright Canon Rewrite</title>
  <style>
    body { margin: 0; overflow: hidden; background:#000; }
    canvas { display:block; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/controls/OrbitControls.js';
import { EffectComposer } from 'three/examples/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/postprocessing/UnrealBloomPass.js';

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”  ðŸ”§  SCENE BASICS
const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 1.4, 1.8);
camera.lookAt(0, 0.6, 0);

const fill = new THREE.DirectionalLight(0xffaa99, 1.5); // "Soft fill light"
fill.position.set(1, 1.5, 2);
scene.add(fill);

const rimLight = new THREE.DirectionalLight(0xff8844, 1.2); // "Back rim light; adds edge definition and glow"
rimLight.position.set(-2, 1, -2);
scene.add(rimLight);

const underLight = new THREE.SpotLight(0xffcc88, 1.4, 3, Math.PI / 4, 0.3, 1.5); // "Underglow spot light"
underLight.position.set(0, -0.3, 0);
underLight.target.position.set(0, 0.3, 0); // Aim it up
scene.add(underLight);
scene.add(underLight.target);

const groundLight = new THREE.HemisphereLight(0xffbb88, 0x220000, 0.4); // "Ground light"
scene.add(groundLight);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = .85;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = .05;
controls.target.set(0, 0.6, 0);

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”  ðŸ’¡  LIGHTS
scene.add(new THREE.AmbientLight(0x221100, .9));
const key = new THREE.PointLight(0xffaa55, 2, 3);
key.position.set(0, 1.4, 0);
scene.add(key);

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”  ðŸŒº  FLOWER GROUP
const flower = new THREE.Group();
scene.add(flower);

// UTIL: petal gradient texture once â€“ reused
function buildPetalTexture(){
  const cvs = document.createElement('canvas');
  cvs.width = cvs.height = 256;
  const ctx  = cvs.getContext('2d');
  const g = ctx.createRadialGradient(128,128,4,128,128,128);
  g.addColorStop(0,'#ffffaa');
  g.addColorStop(.38,'#ff6600');
  g.addColorStop(.8,'#aa1100');
  g.addColorStop(1,'#110000');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,256,256);
  return new THREE.CanvasTexture(cvs);
}
const petalTex = buildPetalTexture();

function createPetal(){
  const s = new THREE.Shape();
  s.moveTo(0, -1.1);
  s.bezierCurveTo(1.2, -1.6, 1.1, 0.4, 0, 1.2);
  s.bezierCurveTo(-1.1, 0.4, -1.2, -1.6, 0, -1.1);

  const geom = new THREE.ExtrudeGeometry(s, {
    depth: .05,
    bevelEnabled: true,
    bevelSize: .03,
    bevelThickness: .015,
    bevelSegments: 3
  });
  geom.center();

  const pos = geom.attributes.position;
  const curveFactor = 0.12;
  for (let i = 0; i < pos.count; i++) {
    const y = pos.getY(i);
    const z = pos.getZ(i);
    pos.setZ(i, z + y * y * curveFactor);
  }
  pos.needsUpdate = true;
  geom.computeVertexNormals();

  const mat = new THREE.MeshPhysicalMaterial({
    map: petalTex,
    transparent: true,
    opacity: .97,
    roughness: .55,
    transmission: .5,
    thickness: .1,
    side: THREE.DoubleSide,
    clearcoat: .25,
    sheen: .15
  });

  const mesh = new THREE.Mesh(geom, mat);
  mesh.scale.set(0.6, 0.65, 0.7);
  mesh.rotateX(Math.PI);
  return mesh;
}

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”  ðŸŸ   BUILD PETALS
const PETAL_COUNT = 5;
const RADIUS = .34;
for(let i=0;i<PETAL_COUNT;i++){
  const petal = createPetal();
  const angle = i / PETAL_COUNT * Math.PI * 2;
  petal.position.set(Math.sin(angle) * RADIUS, 0, Math.cos(angle) * RADIUS);
  petal.lookAt(0, 0, 0);
  petal.rotateX(Math.PI);
  petal.rotateX(-Math.PI / 3);
  flower.add(petal);
}

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”  ðŸŸ¡  STAMEN (main stem)
const STAMEN_H = .68;
const stamen = new THREE.Mesh(
  new THREE.CylinderGeometry(.012,.009, STAMEN_H, 8),
  new THREE.MeshStandardMaterial({ color:0xffffaa, emissive:0xffaa00, emissiveIntensity:1.15 })
);
stamen.position.set(0, STAMEN_H / 2 - 0.3, 0);
flower.add(stamen);

const HAIR_COUNT = 234;
const HAIR_LENGTH = 0.023;
const HAIR_BAND_HEIGHT = 0.15;
for(let i = 0; i < HAIR_COUNT; i++){
  const g = new THREE.CylinderGeometry(0.0015, 0.0015, HAIR_LENGTH, 6);
  const m = new THREE.MeshStandardMaterial({ color: 0xffdd55, emissive: 0xffaa33, emissiveIntensity: 0.25 });
  const hair = new THREE.Mesh(g, m);
  const angle = Math.random() * Math.PI * 2;
  const height = (Math.random() - 0.5) * HAIR_BAND_HEIGHT;
  const radius = 0.015 + Math.random() * 0.01;
  const y = STAMEN_H/2 - 0.2 + height;
  hair.position.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
  hair.lookAt(0, y, 0);
  hair.rotateX(Math.PI / 2);
  flower.add(hair);
}

const stigmaGroup = new THREE.Group();
const STIGMA_Y = STAMEN_H - 0.3;
const STIGMA_HAIR_COUNT = 24;
const STIGMA_HAIR_LEN = 0.04;
const STIGMA_RADIUS = 0.012;
for (let i = 0; i < STIGMA_HAIR_COUNT; i++) {
  const angle = (i / STIGMA_HAIR_COUNT) * Math.PI * 2;
  const dir = new THREE.Vector3(Math.cos(angle), 0.5, Math.sin(angle)).normalize();
  const hairGeom = new THREE.CylinderGeometry(0.0012, 0.0012, STIGMA_HAIR_LEN, 6);
  const hairMat = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xffcc66, emissiveIntensity: 1.5 });
  const hair = new THREE.Mesh(hairGeom, hairMat);
  const base = new THREE.Vector3().copy(dir).multiplyScalar(STIGMA_RADIUS);
  hair.position.set(base.x, STIGMA_Y, base.z);
  hair.lookAt(base.x + dir.x, STIGMA_Y + dir.y, base.z + dir.z);
  stigmaGroup.add(hair);
  const dot = new THREE.Mesh(
    new THREE.SphereGeometry(0.006, 6, 6),
    new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffdd55, emissiveIntensity: 2 })
  );
  dot.position.set(
    base.x + dir.x * STIGMA_HAIR_LEN / 2,
    STIGMA_Y + dir.y * STIGMA_HAIR_LEN / 2,
    base.z + dir.z * STIGMA_HAIR_LEN / 2
  );
  stigmaGroup.add(dot);
}

const coreStigma = new THREE.Mesh(
  new THREE.SphereGeometry(0.025, 8, 8),
  new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffcc55, emissiveIntensity: 1.7 })
);
coreStigma.position.set(0, STIGMA_Y, 0);
stigmaGroup.add(coreStigma);
flower.add(stigmaGroup);

const core = new THREE.PointLight(0xffaa00, 1.3, 1.4);
core.position.set(0,.02,0);
flower.add(core);

// âœ¨ POST FX
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), .9,.35,.8));

// ðŸŽ® LOOP
function loop(){
  requestAnimationFrame(loop);

  const t = performance.now() * 0.001;
  const cycleDuration = 2.4;
  const cycle = t % cycleDuration;

  let pulse = 0;

  const pulsePoints = [
    { t: 0.0, p: 0.0 },
    { t: 0.1, p: 1.0 },
    { t: 0.3, p: 0.2 },
    { t: 0.4, p: 0.5 },
    { t: 1.8, p: 0.0 },
    { t: cycleDuration, p: 0.0 }
  ];

  for (let i = 0; i < pulsePoints.length - 1; i++) {
    const p1 = pulsePoints[i];
    const p2 = pulsePoints[i + 1];
    if (cycle >= p1.t && cycle <= p2.t) {
      const segmentDuration = p2.t - p1.t;
      const timeInSegment = cycle - p1.t;
      const t_normalized = timeInSegment / segmentDuration;
      pulse = p1.p + (p2.p - p1.p) * t_normalized;
      break;
    }
  }

  core.intensity = 0.25 + pulse * 1.8;
  coreStigma.material.emissiveIntensity = 0.3 + pulse * 2.6;
  composer.passes[1].strength = 0.5 + pulse * 0.7;

  flower.rotation.y += 0.0025;
  controls.update();
  composer.render();
}
loop();

// resize
addEventListener('resize',()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
  composer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
